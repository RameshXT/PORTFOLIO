<!DOCTYPE html>
<html lang="en">

<head>
    <!-- -------[ CHARACTER ENCODING ]------- -->
    <meta charset="UTF-8">

    <!-- -------[ RESPONSIVE ]------- -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- -------[ PROJECT TITLE ]-------@RameshXT -->
    <title>Document | Portfolio</title>

    <!-- ?-------[ FAVICON LINK ]------- -->
    <link rel="icon" href="/assets/favicon/favicon.png">

    <!-- ?-------[ CSS LINKS ]------- -->
    <link rel="stylesheet" href="/documentation/portfolio/style.css">
    
</head>
<body>
    <!-- !-------[ HEADER START ]------- -->

<div id="container">

    <!-- [ PROJECT TITLE ] -->
    <header>
        <h1>Portfolio Workflow</h1> <br>
        <p class="intro">Explore the step-by-step process I used to build my portfolio.</p>
    </header>

    <!-- [ PROJECT TITLE ] -->
    <section id="workflow">

        <!-- [ PLAN & RESEARCH ] -->
        <div class="workflow-step" data-step="1">
            <h2>Planning & ResearchüìÖ</h2>
            <p>As a fresher, I approached this project with the goal of showcasing my potential and foundational skills. My planning phase included:</p>
            <p><strong>Setting Clear Goals:</strong> Defined the purpose of the portfolio ‚Äî to highlight my academic projects, technical skills, and enthusiasm for the field.</p>
            <p><strong>Researching Other Portfolios:</strong> Explored portfolios created by other entry-level professionals to understand industry standards and find design inspiration.</p>
            <p><strong>Building a Project Outline:</strong> Created a straightforward plan with a timeline and essential steps to keep the project organized and manageable.</p>
        </div>

        <!-- [ DESIGN ] -->
        <div class="workflow-step" data-step="2">
            <h2>Design & Wireframingüé®</h2>
            <p>In this phase, I focused on translating my ideas into a visual structure. To achieve a clean and organized layout, I:</p>
            <p><strong>Sketched Wireframes:</strong> I began by creating rough paper sketches to plan the structure of the portfolio. These sketches helped define the placement of key sections, the navigation flow, and the overall layout of the design. This initial stage allowed me to visualize the user experience and make adjustments before moving on to digital wireframing.</p>
            <!-- <p><strong>Developed Design Mockups:</strong> Used design tools to create mockups, experimenting with colors, typography, and spacing to ensure a visually appealing and professional look.</p>
            <p><strong>User-Centered Approach:</strong> Kept the layout intuitive and easy to navigate, prioritizing simplicity and clarity so users can easily explore my work.</p> -->
        </div>

        <!-- [ DEVELOPMENT ] -->
        <div class="workflow-step" data-step="3">
            <h2>Developmentüíª</h2>
            <p>Built the frontend with HTML, CSS, and JavaScript for structure and interaction.</p>
            
            <!-- Tool Images -->
            <div class="tool-images">
                <a href="https://developer.mozilla.org/en-US/docs/Web/HTML" target="_blank">
                    <img src="/assets/icons/tools-icons/html/html.png" alt="HTML" class="tool-image">
                </a>
                <a href="https://developer.mozilla.org/en-US/docs/Web/CSS" target="_blank">
                    <img src="/assets/icons/tools-icons/css/css.png" alt="CSS" class="tool-image">
                </a>
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank">
                    <img src="/assets/icons/tools-icons/javascript/javascript.png" alt="JavaScript" class="tool-image">
                </a>
            </div>

        </div>

        <!-- [ DEBUGGING ] -->
        <!-- <div class="workflow-step" data-step="4">
            <h2>Testing & Debugging</h2>
            <p>Tested across devices and browsers, fixing issues for consistency.</p>
        </div> -->

<!-- [ DEPLOYMENT START ] -->
<div class="workflow-step" data-step="5">
    <h2>DeploymentüöÄ</h2>
    
    <p><strong>Launch instance</strong></p>
    <p>&#x2022; To launch an instance using terraform.</p>

    <!-- [ TERRAFORM ] -->
    <p>&#x2022; This file specifies the AWS provider and region. create a file called <strong>provider.tf</strong></p>
    <div class="code-section">
        <p>terraform</p>
        <pre><code>provider "aws" {
region = "us-east-1"
}</code></pre>
        <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
    </div><br><br>

    <p>&#x2022;  This file defines an <strong>EC2</strong> instance with the specified configuration, including the instance type, AMI, security group, and root block device. create a file called <strong>ec2.tf</strong></p>
    <div class="code-section">
        <p>terraform</p>
        <pre><code># SG
data "aws_security_group" "existing" {
  filter {
    name   = "group-name"
    values = ["Primary-SG"]
  }
}

# EC2
resource "aws_instance" "my_ec2" {
  ami           = "ami-06b21ccaeff8cd686"
  instance_type = "t3.medium"

  vpc_security_group_ids = [data.aws_security_group.existing.id]
  key_name        = "Primary-KEY"

  root_block_device {
    volume_type = "gp3"
    volume_size = 30
  }

  tags = {
    Name = "PortFolio"
  }
}</code></pre>
        <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
    </div><br><br>

        <p>&#x2022; To apply this configuration, navigate to the directory with these files and run</p>
        <div class="code-section">
            <p>terraform</p>
            <pre><code>terraform init</code></pre>
            <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
        </div>
        <div class="code-section">
            <p>terraform</p>
            <pre><code>terraform plan</code></pre>
            <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
        </div>

        <p>&#x2022; Run apply command and give value "yes"</p>
        <div class="code-section">
            <p>terraform</p>
            <pre><code>terraform apply</code></pre>
            <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
        </div><br><br>

        <p>&#x2022; Output:</p>
        <div class="image-section">
            <!-- <p>Image Placeholder: Screenshot of the deployed site.</p> -->
            <img src="/documentation/portfolio/assets/terraform/apply.png" alt="">
        </div><br><br>

            <!-- [ Placeholder ] -->
<div class="image-section">
    <!-- <p>Image Placeholder: Screenshot of the deployed site.</p> -->
    <img src="/documentation/portfolio/assets/terraform/ec2.png" alt="">
</div><br><br>

<p>&#x2022; Connect to Your Instance </p>

    <div class="code-section">
        <p>bash</p>
        <pre><code>ssh ec2-user@instance-ip-address</instance-ip-address></code></pre>
        <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
    </div><br><br>

        <!-- [ Placeholder ] -->
        <p>&#x2022; Create <strong>setup.sh</strong> Script</p>
        <p>Inside the instance, create a new bash script called setup.sh. This script will set up Jenkins with suggested and required plugins.</p>
        <div class="code-section">
            <p>bash</p>
            <pre><code>nano setup.sh</code></pre>
            <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
        </div><br><br>

            <!-- [ Placeholder ] -->
    <p>Paste the following into the setup.sh file:</p>
    <div class="code-section">
        <p>bash</p>
        <pre><code>#!/bin/bash
            
# -------[ COLOUR ]-------
GREEN="\e[32m"
BLUE="\e[34m"
RED="\e[31m"
NC="\e[0m"

# -------[ UPDATE SYSTEM PACKAGES ]-------
echo -e "${GREEN}Updating system packages...${NC}"
sudo yum update -y

# -------[ INSTALL REQUIRED APPLICATIONS ]-------

# -------[ CROND INSTALLATION ]-------
# Check if crond is installed
if ! command -v crond &> /dev/null; then
    echo -e "${GREEN}Cron is not installed. Installing now...${NC}"
    
    # Update the package list and install cronie
    sudo yum install cronie -y
    
    # Enable and start the crond service
    sudo systemctl enable crond
    sudo systemctl start crond
    sleep 5

    echo -e "${GREEN}Cron installed successfully.${NC}"
else
    echo -e "${BLUE}Cron is already installed.${NC}"
fi


# -------[ CURL INSTALLATION ]-------
# Function to install curl
install_curl() {
    echo "Installing curl..."
    sudo yum install -y curl
}

# Check if curl is installed
if command -v curl >/dev/null 2>&1; then
    echo "${BLUE}curl is already installed.${NC}"
else
    install_curl
    if command -v curl >/dev/null 2>&1; then
        echo "${GREEN}curl has been installed successfully.${NC}"
    else
        echo "${RED}Failed to install curl.${NC}"
        exit 1
    fi
fi


# -------[ GIT INSTALLATION ]-------
if command -v git &> /dev/null; then
    echo -e "${BLUE}Git is already installed.${NC}"
else
    echo -e "${GREEN}Git is not installed. Installing Git...${NC}"
    sudo yum install git -y
    sleep 2
    echo -e "${GREEN}Git is installed.${NC}"
fi


# -------[ JENKINS INSTALLATION ]-------
if systemctl list-unit-files | grep -q jenkins; then
    echo -e "${BLUE}Jenkins is already installed.${NC}"
else
    echo -e "${GREEN}Jenkins is not installed. Installing Jenkins...${NC}"
    
    sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
    sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key
    
    sudo dnf install java-17-amazon-corretto -y
    sudo yum install jenkins -y
    
    sudo systemctl enable jenkins
    sudo systemctl start jenkins
    sleep 10  # Wait for Jenkins service to start

    echo -e "${GREEN}Jenkins is installed.${NC}"
fi


# -------[ DOCKER INSTALLATION ]-------
if command -v docker &> /dev/null; then
    echo -e "${BLUE}Docker is already installed.${NC}"
else
    echo -e "${GREEN}Docker is not installed. Installing Docker...${NC}"
    
    sudo amazon-linux-extras install docker -y
    sudo yum install docker -y
    
    sudo service docker start
    sleep 5  # Wait for Docker service to start
    sudo usermod -aG docker ec2-user
    
    echo -e "${GREEN}Docker installation and configuration is complete.${NC}"
fi


# -------[ KUBECTL INSTALLATION ]-------
if command -v kubectl &> /dev/null; then
    echo -e "${BLUE}kubectl is already installed.${NC}"
else
    echo -e "${GREEN}kubectl is not installed. Installing kubectl...${NC}"
    
    curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"

    chmod +x ./kubectl
    sudo mv ./kubectl /usr/local/bin/kubectl
    echo -e "${GREEN}kubectl installed successfully.${NC}"
    kubectl version --client
fi


# -------[ MINIKUBE INSTALLATION ]-------
if command -v minikube &> /dev/null; then
    echo -e "${BLUE}Minikube is already installed.${NC}"
else
    echo -e "${GREEN}Minikube is not installed. Installing Minikube...${NC}"
    
    curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
    chmod +x minikube-linux-amd64
    sudo mv minikube-linux-amd64 /usr/local/bin/minikube
    echo -e "${GREEN}Minikube installation is complete.${NC}"
fi


# -------[ CONFIGURATIONS AND PERMISSIONS ]-------
# -------[ ADDING SUDO PERMISSION FOR JENKINS ]-------
if grep -q "^jenkins:" /etc/passwd; then
    if ! sudo grep -q "^jenkins " /etc/sudoers; then
        echo -e "jenkins ALL=(ALL) NOPASSWD: ALL" | sudo tee -a /etc/sudoers > /dev/null
        echo -e "${GREEN}Added Jenkins to sudoers.${NC}"
    else
        echo -e "${BLUE}Jenkins already has sudo permissions.${NC}"
    fi
else
    echo -e "${RED}Jenkins user not found.${NC}"
fi


# -------[ SET JENKINS SHELL TO /bin/bash ]-------
PASSWD_FILE="/etc/passwd"
if grep -q "^jenkins:.*:/bin/false" "$PASSWD_FILE"; then
    sudo sed -i 's|^jenkins:.*:/bin/false|jenkins:x:992:992:Jenkins Automation Server:/var/lib/jenkins:/bin/bash|' "$PASSWD_FILE"
    echo -e "${GREEN}Jenkins shell changed to /bin/bash.${NC}"
else
    echo -e "${BLUE}Jenkins shell already set to /bin/bash.${NC}"
fi



# -------[ CREATE A FILE FOR JENKINS IP CHANGE ]-------

# Define the file path
FILE_PATH="/home/ec2-user/jenkins-ip.sh"

# Define the content to be written
CONTENT='#!/bin/bash

# Fetch the instance public IP address
NEW_IP=$(curl -s ifconfig.me)

# Define the path to the Jenkins configuration file
JENKINS_CONFIG="/var/lib/jenkins/jenkins.model.JenkinsLocationConfiguration.xml"

# Check if the configuration file exists
if [ -f "$JENKINS_CONFIG" ]; then
    # Use sed to replace the old IP with the new IP in the jenkinsUrl line
    sudo sed -i "s|<jenkinsUrl>http://[0-9.]*:8080/</jenkinsUrl>|<jenkinsUrl>http://$NEW_IP:8080/</jenkinsUrl>|" "$JENKINS_CONFIG"
    echo -e "${GREEN}Updated jenkinsUrl to http://$NEW_IP:8080/${NC}"
    
    # Restart Jenkins service
    sudo systemctl restart jenkins

    echo -e "${GREEN}Jenkins has been restarted.${NC}"
else
    echo -e "${GREEN}Jenkins configuration file not found: $JENKINS_CONFIG${NC}"
fi'

# Create the file and write the content
echo "$CONTENT" > "$FILE_PATH"

# Make the file executable
chmod +x "$FILE_PATH"

echo -e "${GREEN}File created at $FILE_PATH with executable permissions.${NC}"


# -------[ CREATE A FILE FOR PORTFORWARD ]-------

# Define the file path
FILE_PATH="/home/ec2-user/portforward.sh"

# Define the content to be written
CONTENT='#!/bin/bash

GREEN="\e[32m"
BLUE="\e[34m"
RED="\e[31m"
NC="\e[0m"

# Port Forwarding
echo "Starting port forwarding..."
kubectl port-forward service/portfolio-service 30050:80 --address 0.0.0.0 > port-forward.log 2>&1 &

# Give it some time to establish the port forwarding
sleep 5

# Check if the port forwarding command is running
if pgrep -f "kubectl port-forward" > /dev/null; then
    echo "${GREEN}Port forwarding established on port 30050${NC}"
    
    # Fetch the public IP of the instance
    public_ip=$(curl -s ifconfig.co)

    # Display the full access URL
    echo "You can access your application at: ${BLUE}http://$public_ip:30050${NC}"
else
    echo "${RED}Failed to establish port forwarding. Check port-forward.log for errors.${NC}"
fi'

# Create the file and write the content
echo "$CONTENT" > "$FILE_PATH"

# Make the file executable
chmod +x "$FILE_PATH"

echo -e "${GREEN}File created at $FILE_PATH with executable permissions.${NC}"


# -------[ ADDING STARTUP COMMANDS ]-------
# Temporary file to hold current crontab
temp_cron=$(mktemp)

# Get current crontab and save to temporary file
crontab -l > "$temp_cron"

# Define the new cron jobs
new_jobs=(
    "@reboot /usr/local/bin/minikube start"
    "@reboot /home/ec2-user/jenkins-ip.sh"
    "@reboot nohup kubectl port-forward service/portfolio-service 30050:80 --address 0.0.0.0 > ~/workspace/port-forward.log 2>&1 &"
)

# Flag to check if any jobs were added
jobs_added=false

# Check if each job is already present in the crontab
for job in "${new_jobs[@]}"; do
    if ! grep -Fxq "$job" "$temp_cron"; then
        echo "$job" >> "$temp_cron"
        jobs_added=true
    fi
done

# Install the new crontab from the temporary file if jobs were added
if [ "$jobs_added" = true ]; then
    crontab "$temp_cron"
    echo -e "${GREEN}New cron jobs added successfully.${NC}"
else
    echo -e "${BLUE}No new cron jobs were added; they already exist.${NC}"
fi

# Remove the temporary file
rm "$temp_cron"


# -------[ START MINIKUBE WITH DOCKER GROUP ]-------
echo -e "${GREEN}Adding ec2-user to docker group...${NC}"
sudo usermod -aG docker ec2-user

echo -e "${GREEN}Switching to docker group and starting Minikube...${NC}"

newgrp docker <<EOF
minikube start
if [ $? -eq 0 ]; then
    echo -e "${GREEN}Minikube started successfully.${NC}"
else
    echo -e "${RED}Failed to start Minikube. Exiting.${NC}"
    exit 1
fi
EOF


# -------[ KUBE CONFIGURATION WITH JENKINS ]-------
# Define source and destination directories
src_kube="/home/ec2-user/.kube"
src_minikube="/home/ec2-user/.minikube"
dest_kube="/var/lib/jenkins/.kube"
dest_minikube="/var/lib/jenkins/.minikube"
config_file="$dest_kube/config"

# Check if the source directories exist
if [ -d "$src_kube" ] && [ -d "$src_minikube" ]; then
    # Copy .kube and .minikube directories to Jenkins' home
    sudo cp -r "$src_kube" "$dest_kube"
    sudo cp -r "$src_minikube" "$dest_minikube"

    # Change ownership of the copied directories to the jenkins user
    sudo chown -R jenkins:jenkins "$dest_kube"
    sudo chown -R jenkins:jenkins "$dest_minikube"

    # Update paths in the config file if it exists
    if [ -f "$config_file" ]; then
        sudo sed -i 's|certificate-authority: /home/ec2-user/.minikube/ca.crt|certificate-authority: /var/lib/jenkins/.minikube/ca.crt|' "$config_file"
        sudo sed -i 's|client-certificate: /home/ec2-user/.minikube/profiles/minikube/client.crt|client-certificate: /var/lib/jenkins/.minikube/profiles/minikube/client.crt|' "$config_file"
        sudo sed -i 's|client-key: /home/ec2-user/.minikube/profiles/minikube/client.key|client-key: /var/lib/jenkins/.minikube/profiles/minikube/client.key|' "$config_file"
    else
        echo "Config file not found at $config_file. Skipping path updates."
    fi
else
    echo "Source directories do not exist. Please check the paths."
    if [ ! -d "$src_kube" ]; then
        echo "Missing: $src_kube"
    fi
    if [ ! -d "$src_minikube" ]; then
        echo "Missing: $src_minikube"
    fi
fi
echo "${GREEN}kube files has beed configured${NC}"


# -------[ VERSION CHECK FOR APPLICATIONS ]-------
printf "%-12s | %-30s\n" "Tool" "Version / Status"
echo -e "${GREEN}=============================================${NC}"
# Git version
if command -v git &> /dev/null; then
    printf "%-12s | %-30s\n" "Git" "$(git --version)"
else
    printf "%-12s | %-30s\n" "Git" "Not Installed"
fi

# Crond
if systemctl list-unit-files | grep -q crond; then
    status=$(systemctl status crond | grep 'Active:' | awk '{print $2, $3, $4}')
    printf "%-12s | %-30s\n" "Crond" "$status"
else
    printf "%-12s | %-30s\n" "Crond" "Not Installed"
fi

# curl
if command -v curl > /dev/null; then
    printf "%-12s | %-30s\n" "Curl" "Installed"
else
    printf "%-12s | %-30s\n" "Curl" "Not Installed"
fi

# Jenkins version
if systemctl list-unit-files | grep -q jenkins; then
    printf "%-12s | %-30s\n" "Jenkins" "$(systemctl status jenkins | grep 'Active:' | awk '{print $2}')"
else
    printf "%-12s | %-30s\n" "Jenkins" "Not Installed"
fi

# Docker version
if command -v docker &> /dev/null; then
    printf "%-12s | %-30s\n" "Docker" "$(docker --version)"
else
    printf "%-12s | %-30s\n" "Docker" "Not Installed"
fi

# kubectl version
if command -v kubectl &> /dev/null; then
    kubectl_version=$(kubectl version --client 2>/dev/null | grep 'Client Version' | awk '{print $3}' | tr -d 'v')
    if [ -z "$kubectl_version" ]; then
        kubectl_version="Not Installed"
    fi
    printf "%-12s | %-30s\n" "kubectl" "$kubectl_version"
else
    printf "%-12s | %-30s\n" "kubectl" "Not Installed"
fi

# Minikube version
if command -v minikube &> /dev/null; then
    minikube_version=$(minikube version --short 2>/dev/null)
    printf "%-12s | %-30s\n" "Minikube" "${minikube_version:-Not Installed}"
else
    printf "%-12s | %-30s\n" "Minikube" "Not Installed"
fi
echo -e "${GREEN}=============================================${NC}"
echo -e "${GREEN}Setup complete!${NC}"


# -------[ DISK SPACE CHECK ]-------
disk_data=($(df -h --output=source,pcent,target | tail -n +2))
echo -e "${GREEN}\n==== Disk Space Usage Map ====\n${NC}"
for ((i = 0; i < ${#disk_data[@]}; i+=3)); do
    source=${disk_data[i]}
    usage=${disk_data[i+1]}
    mount=${disk_data[i+2]}
    bar_length=${usage//%/}
    bar=$(printf "%-${bar_length}s" | tr ' ' '=')
    
    echo -e "${GREEN}$source mounted on $mount${NC}"
    echo -e "[${GREEN}${bar//=/‚ñì}${NC} ${usage}]\n"
done
echo -e "${GREEN}==============================${NC}"


# -------[ JENKINS INITIAL ADMIN PASSWORD ]-------
JENKINS_PASSWORD_FILE="/var/lib/jenkins/secrets/initialAdminPassword"
TEMP_PASSWORD_FILE="/tmp/jenkins_password.txt"

# Check if the password file exists and fetch it using sudo
if sudo test -f "$JENKINS_PASSWORD_FILE"; then
    echo -e "${GREEN}Retrieving Jenkins Initial Admin Password...${NC}"
    
    # Create a temporary file with the password
    sudo cat "$JENKINS_PASSWORD_FILE" > "$TEMP_PASSWORD_FILE"
    
    # Check if the temporary file was created successfully
    if [[ -f "$TEMP_PASSWORD_FILE" ]]; then
        echo -e "${GREEN}Password retrieved successfully:${NC}"
        cat "$TEMP_PASSWORD_FILE"
        # Optionally, remove the temporary file afterward
        rm -f "$TEMP_PASSWORD_FILE"
    else
        echo -e "${RED}Failed to retrieve the password.${NC}"
    fi
else
    echo -e "${RED}Jenkins initial admin password file not found!${NC}"
fi</code></pre>
        <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
    </div><br><br>
    


            <!-- [ Placeholder ] -->
            <p>Make the script executable and run it:</p>
            <div class="code-section">
                <p>bash</p>
                <pre><code>chmod +x setup.sh
bash setup.sh</code></pre>
                <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
            </div><br><br>
            <p>This script will install Jenkins, Docker, Git, java, curl, crond, kubectl, and minikube start their services, and install the necessary plugins.</p>

            <p>&#x2022; Output:</p>
            <div class="image-section">
                <!-- <p>Image Placeholder: Screenshot of the deployed site.</p> -->
                <img src="/documentation/portfolio/assets/terraform/install.png" alt="">
            </div><br><br>


            <strong>Dockerfile</strong>
            <p>The Dockerfile is used to create a Docker image for your application.</p>
            <div class="code-section">
                <p>Dockerfile</p>
                <pre><code>FROM ubuntu:20.04

ARG DEBIAN_FRONTEND=noninteractive

RUN apt-get update && apt-get install -y apache2

RUN rm -rf /var/www/html/*

COPY . /var/www/html/

EXPOSE 80

CMD ["apachectl", "-D", "FOREGROUND"]</code></pre>
                <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
            </div><br><br>


            <strong>deployment.yaml</strong>
            <p>This Kubernetes manifest file is used to create a Deployment for your application in a Kubernetes cluster.</p>
            <div class="code-section">
                <p>yaml</p>
                <pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: portfolio
spec:
  replicas: 1
  selector:
    matchLabels:
      app: portfolio
  template:
    metadata:
      labels:
        app: portfolio
    spec:
      containers:
      - name: portfolio-container
        image: UPDATE-IMAGE  # This will be updated
        ports:
        - containerPort: 80</code></pre>
                <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
            </div><br><br>

            <strong>service.yaml</strong>
            <p>This file exposes your application as a service within the Kubernetes cluster.</p>
            <div class="code-section">
                <p>yaml</p>
                <pre><code>apiVersion: v1
kind: Service
metadata:
  name: portfolio-service
spec:
  selector:
    app: portfolio
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
      nodePort: 30050
  type: NodePort</code></pre>
                <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
            </div><br><br>

            <strong>Jenkinsfile</strong>
            <p>The Jenkinsfile defines your CI/CD pipeline, handling steps like building the Docker image, pushing it to Docker Hub, and deploying it to Kubernetes.</p>
            <div class="code-section">
                <p>groovy</p>
                <pre><code>pipeline
{
    agent any
    stages
    {
        stage("CLEANING THE WORKSPACE")
        {
            steps
            {
                script
                {
                    def workspaceDir = "/var/lib/jenkins/workspace/portfolio-ramesh/"
                    
                    if (fileExists(workspaceDir))
                    {
                        sh "sudo rm -rf ${workspaceDir}*"
                    }
                    else
                    {
                        echo "Workspace directory doesn't exist."
                    }
                }
            }
        }

        stage("GIT CHECKOUT")
        {
            steps
            {
                echo "Checking out branch: portfolio from repository: https://github.com/RameshXT/PORTFOLIO.git"

                git branch: 'portfolio', credentialsId: 'GitHub-ID', url: 'https://github.com/RameshXT/PORTFOLIO.git'

                echo "Successfully checked out branch: portfolio."
            }
        }

        stage("DELETING EXISTING IMAGES AND CONTAINERS")
        {
            steps
            {
                script
                {
                    def keepImage = "gcr.io/k8s-minikube/kicbase:v0.0.45"
                    def keepContainer = "minikube"

                    def containers = sh(script: "sudo docker ps -a -q", returnStdout: true).trim()
                    if (containers)
                    {
                        sh "sudo docker ps -q | grep -v \$(sudo docker ps --filter 'name=${keepContainer}' -q) | xargs -r sudo docker stop"
                        sh "sudo docker ps -a -q | grep -v \$(sudo docker ps --filter 'name=${keepContainer}' -q) | xargs -r sudo docker rm"
                        echo "Containers successfully deleted, except '${keepContainer}'!"
                    }
                    else
                    {
                        echo "No containers are there to delete!"
                    }

                    def images = sh(script: "sudo docker images -q", returnStdout: true).trim()
                    if (images)
                    {
                        sh "sudo docker images -q | grep -v \$(sudo docker images --filter=reference=${keepImage} -q) | xargs -r sudo docker rmi --force"
                        echo "Images successfully deleted, except '${keepImage}'!"
                    }
                    else
                    {
                        echo "No images are there to delete!"
                    }
                }
            }
        }

        stage("BUILDING DOCKER IMAGE")
        {
            steps
            {
                script
                {
                    def dockerImageTag = "rameshxt/portfolio-ramesh:v1.0.0.${env.BUILD_NUMBER}"
                    echo "Building Docker image with tag: ${dockerImageTag}"

                    sh "sudo docker build -t ${dockerImageTag} /var/lib/jenkins/workspace/portfolio-ramesh"
                    echo "Docker image ${dockerImageTag} built successfully."
                }
            }
        }

        stage("DOCKER LOGIN")
        {
            steps
            {
                withCredentials([string(credentialsId: 'Docker-ID', variable: 'Docker')])
                {
                    sh """
                        sudo docker login -u rameshxt -p "${Docker}"
                    """
                    echo "Docker logged in successfully."
                }
            }
        }

        stage('PUSHING IMAGE TO DOCKER HUB')
        {
            steps
            {
                script
                {
                    def dockerImageTag = "rameshxt/portfolio-ramesh:v1.0.0.${env.BUILD_NUMBER}"
                    sh "sudo docker push ${dockerImageTag}"
                    
                    echo "Docker image ${dockerImageTag} pushed to Docker Hub successfully."
                }
            }
        }

        stage('IMAGE VERSION UPDATER')
        {
            steps
            {
                script
                {
                    echo "Current Build Number: ${env.BUILD_NUMBER}"
                    
                    sh "chmod +x /var/lib/jenkins/workspace/portfolio-ramesh/deploy/image-updater.sh"
                    echo "Made image-updater.sh executable."

                    sh "/var/lib/jenkins/workspace/portfolio-ramesh/deploy/image-updater.sh"
                    echo "Image has been updated successfully."
                }
            }
        }

        stage('DEPLOY TO KUBERNETES')
        {
            steps
            {
                sh "kubectl apply -f /var/lib/jenkins/workspace/portfolio-ramesh/deploy/kube/deployment.yaml"
                echo "Deployment applied successfully."

                sh "kubectl apply -f /var/lib/jenkins/workspace/portfolio-ramesh/deploy/kube/service.yaml"
                echo "Service applied successfully."
                
                sh "nohup kubectl port-forward service/portfolio-service 30050:80 --address 0.0.0.0 > ~/workspace/port-forward.log 2>&1 &"
                echo "Port forwarding started on port 30050."
            }
        }

        stage('ACCESS PORTFOLIO')
        {
            steps
            {
                script
                {
                    def publicIP = sh(script: 'curl -s ifconfig.me', returnStdout: true).trim()
                    def accessMessage = "Congrats!!üéâ Your portfolio is running at the following link: http://${publicIP}:30050 üöÄ"
                    
                    echo "${accessMessage}"
                }
            }
        }
    }

    post
    {
        success
        {
            echo '‚úÖ BUILD COMPLETED SUCCESSFULLY!'
        }
        failure
        {
            echo '‚ùå BUILD FAILED!'
        }
    }
}</code></pre>
                <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
            </div><br><br>
<p>&#x2022; DOCKER_IMAGE: Replace your-dockerhub-username/your-app-image with your Docker Hub username and repository name.</p>
<p>&#x2022; DOCKER_CREDENTIALS_ID: Set to the Jenkins credential ID created for Docker Hub authentication.</p> <br>



<strong>Set Up the Jenkins Pipeline Job</strong><br>
<p>1. In Jenkins, create a new <strong>Pipeline</strong> job.</p>
<p>2. Choose <strong>Pipeline script from SCM</strong> in the job configuration.</p>
<p>3. Select <strong>SCM</strong> as <strong>Git</strong>.</p>
<p>4. Paste your repository URL into the <strong>Repository URL</strong> field.</p>
<p>5. If your repository is private, add the necessary credentials for access.</p>
<p>6. Select the branch you want to build.</p>
<p>7. Specify <strong>Jenkinsfile</strong> as the <strong>Script Path</strong>.</p>
<p>Save and apply the configuration.</p>

<br><strong>Add Docker Hub Credentials</strong><br>
<p>1. In the Jenkins Dashboard, go to <strong>Credentials > System > Global credentials (unrestricted).</strong></p>
<p>2. Add credentials:</p>
<p>&#x2022; select with credentials and bind variable</p>
<p>&#x2022; <strong>Secret:</strong> Add your Docker Hub credentials here</p>
<p>&#x2022; <strong>ID:</strong> Choose a unique ID like Docker-Id</p>
<p>3. To bind credentials in your <strong>Jenkinsfile,</strong> generate a <strong>withCredentials</strong> block:</p>
<p>&#x2022; In Pipeline Syntax, choose withCredentials: Bind credentials to variables.</p>
<p>&#x2022; Select Secret text and provide a variable name like Docker.</p>
<p>&#x2022; Add your Docker Hub credential.</p> <br>


<!-- [ Placeholder ] -->
<p>Then, your Jenkinsfile might include:</p>
    <div class="code-section">
        <p>bash</p>
        <pre><code>withCredentials([string(credentialsId: 'Docker-Id', variable: 'Docker')]) {
// Docker-related steps
}
        </code></pre>
        <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
    </div><br><br>
    
<strong>Navigate to Jenkins Dashboard and Build the Project</strong>
<p>1. Go to Jenkins Dashboard:</p>
<p>&#x2022; From your Jenkins home page, locate your pipeline job (the one you created earlier with "Pipeline script from SCM").</p>

<p>2. Trigger the Build:</p>
<p>&#x2022; Click on your project/job name.</p>
<p>&#x2022; On the left side, click on <strong>Build Now</strong>.</p>
<p>&#x2022; This will start a new build of the <strong>pipeline</strong> using the Jenkinsfile from your specified repository.</p>

<p>3. Monitor Build Progress:</p>
<p>&#x2022; After triggering the build, you can view the progress in <strong>Build History</strong>. Click on the build number <strong>(e.g., #1)</strong> to open the build details.</p>
<p>&#x2022; Choose <strong>Console Output</strong> to see detailed logs of each step in the pipeline, including plugin installation, Docker commands, and any other actions specified in your Jenkinsfile.</p>

<p>&#x2022; Once the build completes successfully:</p>
<div class="image-section">
    <!-- <p>Image Placeholder: Screenshot of the deployed site.</p> -->
    <img src="/documentation/portfolio/assets/terraform/build.png" alt="">
</div><br><br>


                <!-- [ Placeholder ] -->
                <br><strong>Manual Port Forwarding with the Script</strong>
                <p>Navigate to the Setup Directory (if not already there):</p>              
                <div class="code-section">
                    <p>bash</p>
                    <pre><code>cd /home/ec2-user</code></pre>
                    <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
                </div><br><br>

                
                            <!-- [ Placeholder ] -->
    <p>Run the Port Forwarding Script:</p>
    <div class="code-section">
        <p>bash</p>
        <pre><code>bash portforward.sh
        </code></pre>
        <button class="copy-btn" onclick="copyCode(this)">Copy code</button>
    </div><br><br>

    <p>This completes the process, and you should now see output confirming that the port forwarding has successfully enabled access to the application running on port 5050.</p>

    <p>&#x2022; Once the build completes successfully:</p>
    <div class="image-section">
        <!-- <p>Image Placeholder: Screenshot of the deployed site.</p> -->
        <img src="/documentation/portfolio/assets/terraform/port.png" alt="">
    </div><br><br>

    <p>After port forwarding, we are able to access our web page using the specified port from outside the world.</p>


    <div class="image-section">
        <!-- <p>Image Placeholder: Screenshot of the deployed site.</p> -->
        <img src="/documentation/portfolio/assets/terraform/webpage.png" alt="">
    </div><br><br>

    <p>We trust the documentation will provide valuable insights. Should you spot any errors, feel free to <strong>send an email</strong> ‚Äì your <strong>feedback</strong> will be highly appreciated. <em>Thank you for your support!</em></p>

    <br><br><hr style="border: 2px solid #4e92df; width: 80%; margin: auto;">

</div>
<!-- [ DEPLOYMENT END ] -->

    </section>
</div>
    <!-- !-------[ HEADER END ]------- -->

<script src="/documentation/portfolio/script.js"></script>
</body>
</html>